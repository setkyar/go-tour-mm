ပက်ကေ့ဂျ်များ, ကိန်းရှင်များ, နှင့် ဖန်ရှင်များ။

Go ပရိုဂရမ်တိုင်း၏ အခြေခံအစိတ်အပိုင်းများကို လေ့လာပါ။

The Go Authors
https://golang.org

* ပက်ကေ့ဂျ်များ

Go ပရိုဂရမ်တိုင်းသည် ပက်ကေ့ဂျ်များဖြင့် ဖွဲ့စည်းထားသည်။

ပရိုဂရမ်များသည် `main` ပက်ကေ့ဂျ်မှ စတင်အလုပ်လုပ်သည်။

ဒီပရိုဂရမ်သည် `"fmt"` နှင့် `"math/rand"` အင်ပေါ့လမ်းကြောင်းများ(import paths) ရှိ ပက်ကေ့ဂျ်များကို အသုံးပြုနေသည်။

သဘောတူထားသည့်အတိုင်း၊ ပက်ကေ့ဂျ်အမည်သည် import paths ၏ နောက်ဆုံးအစိတ်အပိုင်းနှင့် တူညီသည်။ ဥပမာအားဖြင့်၊ `"math/rand"` ပက်ကေ့ဂျ်သည် `package`rand` ကြေညာချက်ဖြင့် စတင်သော ဖိုင်များပါဝင်သည်။

#appengine: *မှတ်ချက်*: ဒီပရိုဂရမ်တွေကို run တဲ့ပတ်ဝန်းကျင်က တသမတ်တည်းဖြစ်တဲ့အတွက် 
#appengine: နမူနာပရိုဂရမ်ကို run တိုင်း rand.Intn က တူညီတဲ့နံပါတ်ကိုပဲ ပြန်ပေးပါလိမ့်မယ်။
#appengine:
#appengine: (ကွဲပြားတဲ့နံပါတ်တစ်ခုကို မြင်ချင်ရင် နံပါတ်ထုတ်ပေးတဲ့စနစ်ကို seed လုပ်ပါ။ 
#appengine: [[https://golang.org/pkg/math/rand/#Seed][rand.Seed]] ကို ကြည့်ပါ။ 
#appengine: Playground မှာ အချိန်က ပုံသေဖြစ်နေတဲ့အတွက် seed အဖြစ် တခြားတစ်ခုခုကို သုံးရပါမယ်။)

.play basics/packages.go

* အင်ပေါ့များ (imports)

ဒီကုဒ်သည် အင်ပေါ့များကို ကွင်းစကွင်းပိတ်ဖြင့် အုပ်စုဖွဲ့ထားသော "factored" အင်ပေါ့ကြေညာချက်အဖြစ် စုစည်းထားသည်။

သင်သည် အင်ပေါ့ကြေညာချက်များကို သီးခြားစီလည်း ရေးနိုင်သည်၊ ဥပမာ -

	import "fmt"
	import "math"

သို့သော် factored အင်ပေါ့ကြေညာချက်ကို အသုံးပြုခြင်းသည် ကောင်းမွန်သော ရေးထုံးဖြစ်သည်။

.play basics/imports.go

* တင်ပို့ထားသော အမည်များ (Exported names)

Go တွင်၊ အမည်တစ်ခုသည် စာလုံးအကြီးဖြင့် စတင်ပါက တင်ပို့ထားသောအမည်ဖြစ်သည်။
ဥပမာအားဖြင့်၊ `Pizza` သည် တင်ပို့ထားသောအမည်ဖြစ်သည်၊ `math` ပက်ကေ့ဂျ်မှ တင်ပို့ထားသော `Pi` လည်း ထိုနည်းတူဖြစ်သည်။

`pizza` နှင့် `pi` တို့သည် စာလုံးအကြီးဖြင့် မစတင်သောကြောင့် ၎င်းတို့ကို တင်ပို့မထားပါ။

ပက်ကေ့ဂျ်တစ်ခုကို အင်ပေါ့လုပ်သောအခါ၊ သင်သည် ၎င်း၏ တင်ပို့ထားသောအမည်များကိုသာ ရည်ညွှန်းနိုင်သည်။
"တင်ပို့မထားသော" မည်သည့်အမည်ကိုမဆို ပက်ကေ့ဂျ်ပြင်ပမှ အသုံးပြု၍မရပါ။ ဆိုလိုတာက Exported လုပ်မထားရင် တခြားပက်ကေ့ဂျ်တွေကသုံးလို့မရဘူး။

ကုဒ်ကို run ပါ။ မက်ဆေ့ချ်က အမှားပြ နေတာကိုသတိပြုပါ။

အမှားကို ပြင်ဆင်ရန်၊ `math.pi` ကို `math.Pi` သို့ ပြောင်းပြီး ထပ်မံကြိုးစားကြည့်ပါ။

.play basics/exported-names.go

* ဖန်ရှင်များ (Functions)

ဖန်ရှင်တစ်ခုသည် အားဂျူးမန့် (argument) များကို လုံးဝမယူခြင်း သို့မဟုတ် အားဂျူးမန့်(arguments)အများအပြားယူခြင်း ပြုလုပ်နိုင်သည်။

ဤဥပမာတွင်၊ `add` သည် `int` အမျိုးအစား ပါရာမီတာ နှစ်ခုကို ယူသည်။

အမျိုးအစားသည် variable အမည်၏ _နောက်တွင်_ ရှိကြောင်း သတိပြုပါ။

(အမျိုးအစားများ အဘယ်ကြောင့် ယခုကဲ့သို့ ပုံသဏ္ဍာန်ရှိသည်ကို ပိုမိုသိရှိလိုပါက [[https://blog.golang.org/gos-declaration-syntax][Go ၏ ကြေညာချက် ဆင်တက်စ်အကြောင်း ဆောင်းပါး]]ကို ကြည့်ပါ။)

.play basics/functions.go

* ဖန်ရှင်များ (ဆက်လက်)

တစ်ခုနှင့်တစ်ခု ဆက်တိုက်ရှိသော အမည်ပါ ဖန်ရှင်ပါရာမီတာ နှစ်ခု သို့မဟုတ် ထို့ထက်ပိုသော ပါရာမီတာများသည် အမျိုးအစားတူညီပါက၊ နောက်ဆုံးတစ်ခုမှလွဲ၍ ကျန်အားလုံး၏ အမျိုးအစားကို ချန်လှပ်ထားနိုင်သည်

ဤဥပမာတွင်၊ ကျွန်ုပ်တို့သည်

	x int, y int

ကို

	x, y int

အဖြစ် တိုတောင်းစေခဲ့သည်

.play basics/functions-continued.go

* ရလဒ်အများအပြား

ဖန်ရှင်တစ်ခုသည် မည်သည့်အရေအတွက်မဆို ရလဒ်များကို ပြန်ပေးနိုင်သည်။

`swap` ဖန်ရှင်သည် စာကြောင်းနှစ်ကြောင်းကို ပြန်ပေးသည်။

.play basics/multiple-results.go

* အမည်ပေးထားသော ပြန်ပေးတန်ဖိုးများ (return values)

Go ၏ ပြန်ပေးတန်ဖိုးများကို အမည်ပေးနိုင်သည်။ ထိုသို့ဆိုပါက၊ ၎င်းတို့ကို ဖန်ရှင်၏ထိပ်ဆုံးတွင် သတ်မှတ်ထားသော variable များအဖြစ် သတ်မှတ်သည်။

ဤအမည်များကို ပြန်ပေးတန်ဖိုးများ၏ အဓိပ္ပါယ်ကို စာရွက်စာတမ်းပြုစုရန် အသုံးပြုသင့်သည်။

အားဂျူးမန့်မပါသော `return` ကြေညာချက်သည် အမည်ပေးထားသော ပြန်ပေးတန်ဖိုးများကို ပြန်ပေးသည်။ ဤသည်ကို "naked" return ဟု သိကြသည်။

Naked return ကြေညာချက်များကို ဤနေရာတွင် ပြထားသောဥပမာကဲ့သို့ တိုတောင်းသော ဖန်ရှင်များတွင်သာ အသုံးပြုသင့်သည်။ ၎င်းတို့သည် ပိုရှည်သော ဖန်ရှင်များတွင် ဖတ်ရှုနိုင်စွမ်းကို ထိခိုက်စေနိုင်သည်။

.play basics/named-results.go

* ကိန်းရှင်များ (Variables)

`var` ကြေညာချက်သည် ကိန်းရှင်များစာရင်းကို ကြေညာသည်။ ဖန်ရှင်အားဂျူးမန့်စာရင်းများကဲ့သို့ပင်၊ အမျိုးအစားသည် နောက်ဆုံးတွင်ရှိသည်။

`var` ကြေညာချက်သည် ပက်ကေ့ဂျ် သို့မဟုတ် ဖန်ရှင်အဆင့်တွင် ရှိနိုင်သည်။ ကျွန်ုပ်တို့သည် ဤဥပမာတွင် နှစ်မျိုးလုံးကို မြင်တွေ့ရသည်။

.play basics/variables.go

* စတင်တန်ဖိုးသတ်မှတ်ချက်များပါသော ကိန်းရှင်များ

var ကြေညာချက်တွင် စတင်တန်ဖိုးသတ်မှတ်ချက်များ ပါဝင်နိုင်သည်၊ ကိန်းရှင်တစ်ခုလျှင် တစ်ခုစီ။

စတင်တန်ဖိုးသတ်မှတ်ချက် ရှိပါက အမျိုးအစားကို ချန်လှပ်ထားနိုင်သည်။ ကိန်းရှင်သည် စတင်တန်ဖိုးသတ်မှတ်ချက်၏ အမျိုးအစားကို ယူမည်ဖြစ်သည်။

.play basics/variables-with-initializers.go

* တိုတောင်းသော ကိန်းရှင်ကြေညာချက်များ

ဖန်ရှင်တစ်ခုအတွင်း၊ `:=` တိုတောင်းသော သတ်မှတ်ချက်ကြေညာချက်ကို ထင်ရှားသော အမျိုးအစားပါသော `var` ကြေညာချက်အစား အသုံးပြုနိုင်သည်။

ဖန်ရှင်ပြင်ပတွင်၊ ကြေညာချက်တိုင်းသည် ကီးဝေါ့ (`var`၊ `func` စသည်ဖြင့်) ဖြင့် စတင်သောကြောင့် `:=` ဖွဲ့စည်းပုံကို အသုံးပြု၍မရပါ။

.play basics/short-variable-declarations.go

* အခြေခံအမျိုးအစားများ

Go ၏ အခြေခံအမျိုးအစားများမှာ -

	bool

	string

	int  int8  int16  int32  int64
	uint uint8 uint16 uint32 uint64 uintptr

	byte // uint8 အတွက် အမည်ပြောင်း

	rune // int32 အတွက် အမည်ပြောင်း
	     // Unicode ကုဒ်အမှတ်တစ်ခုကို ကိုယ်စားပြုသည်

	float32 float64

	complex64 complex128

ဒီဥပမာမှာ အမျိုးအစားအမျိုးမျိုးရဲ့ ကိန်းရှင်တွေကို ပြထားပါတယ်။
ထို့အပြင် ကိန်းရှင်ကြေညာချက်တွေကို အင်ပေါ့ကြေညာချက်တွေလိုပဲ "factored" လုပ်ပြီး ဘလော့တွေအဖြစ် စုစည်းနိုင်ကြောင်းလည်း ပြထားပါတယ်။

`int`၊ `uint` နဲ့ `uintptr` အမျိုးအစားတွေဟာ 32-ဘစ် စနစ်တွေမှာ 32 ဘစ် အကျယ်ရှိပြီး၊ 64-ဘစ် စနစ်တွေမှာ 64 ဘစ် အကျယ်ရှိပါတယ်။
ကိန်းပြည့်တန်ဖိုးတစ်ခု လိုအပ်တဲ့အခါ သီးခြားအကြောင်းပြချက်မရှိရင် `int` ကိုသုံးသင့်ပါတယ်။ အရွယ်အစားသတ်မှတ်ထားတဲ့ သို့မဟုတ် အနုတ်လက္ခဏာမပါတဲ့ ကိန်းပြည့်အမျိုးအစားကို မသုံးသင့်ပါဘူး။

.play basics/basic-types.go

* သုညတန်ဖိုးများ

တိကျတဲ့ ကနဦးတန်ဖိုးမပါဘဲ ကြေညာထားတဲ့ ကိန်းရှင်တွေကို သူတို့ရဲ့
_သုည_ တန်ဖိုး ပေးထားပါတယ်။

သုညတန်ဖိုးတွေက:

- ကိန်းဂဏန်းအမျိုးအစားတွေအတွက် `0`၊
- ဘူးလီးယန်းအမျိုးအစားအတွက် `false`၊ နဲ့
- စာကြောင်းတွေအတွက် `""` (ဗလာစာကြောင်း) တို့ဖြစ်ပါတယ်။

.play basics/zero.go

* အမျိုးအစားပြောင်းလဲခြင်းများ

`T(v)` ဖော်ပြချက်က တန်ဖိုး `v` ကို အမျိုးအစား `T` အဖြစ် ပြောင်းလဲပါတယ်။

ကိန်းဂဏန်းပြောင်းလဲမှုအချို့:

	var i int = 42
	var f float64 = float64(i)
	var u uint = uint(f)

ဒါမှမဟုတ် ပိုရိုးရှင်းအောင် ရေးရင်:

	i := 42
	f := float64(i)
	u := uint(f)

C နဲ့မတူဘဲ၊ Go မှာ မတူညီတဲ့အမျိုးအစားတွေကြား သတ်မှတ်မှုပြုလုပ်တဲ့အခါ တိကျတဲ့ပြောင်းလဲမှုတစ်ခု လိုအပ်ပါတယ်။
ဥပမာထဲက `float64` သို့မဟုတ် `uint` ပြောင်းလဲမှုတွေကို ဖယ်ထုတ်ကြည့်ပြီး ဘာဖြစ်လဲဆိုတာ ကြည့်ပါ။

.play basics/type-conversions.go

* အမျိုးအစားကောက်ချက်ချခြင်း (Type inference)

တိကျတဲ့အမျိုးအစားကို မသတ်မှတ်ဘဲ ကိန်းရှင်တစ်ခုကို ကြေညာတဲ့အခါ (`:=` syntax သို့မဟုတ် `var = ` ဖော်ပြချက် syntax ကိုသုံးပြီး)၊ ကိန်းရှင်ရဲ့အမျိုးအစားကို ညာဘက်ခြမ်းက တန်ဖိုးကနေ ကောက်ချက်ချပါတယ်။

ကြေညာချက်ရဲ့ ညာဘက်ခြမ်းမှာ အမျိုးအစားသတ်မှတ်ထားရင်၊ ကိန်းရှင်အသစ်က အဲဒီအမျိုးအစားအတိုင်းဖြစ်ပါတယ်:

	var i int
	j := i // j က int ဖြစ်ပါတယ်

ဒါပေမယ့် ညာဘက်ခြမ်းမှာ အမျိုးအစားမသတ်မှတ်ထားတဲ့ ကိန်းဂဏန်းကိန်းသေပါရင်၊ ကိန်းရှင်အသစ်က ကိန်းသေရဲ့ တိကျမှုပေါ်မူတည်ပြီး `int`၊ `float64`၊ သို့မဟုတ် `complex128` ဖြစ်နိုင်ပါတယ်:

	i := 42           // int
	f := 3.142        // float64
	g := 0.867 + 0.5i // complex128

ဥပမာကုဒ်ထဲက `v` ရဲ့ ကနဦးတန်ဖိုးကို ပြောင်းကြည့်ပြီး သူ့ရဲ့အမျိုးအစား ဘယ်လိုထိခိုက်လဲဆိုတာ လေ့လာကြည့်ပါ။

.play basics/type-inference.go

* ကိန်းသေများ (Constants)

ကိန်းသေတွေကို ကိန်းရှင်တွေလိုပဲ ကြေညာပါတယ်၊ ဒါပေမယ့် `const` ကီးဝေါ့နဲ့ ကြေညာပါတယ်။

ကိန်းသေတွေဟာ စာလုံး၊ စာကြောင်း၊ ဘူးလီးယန်း၊ သို့မဟုတ် ကိန်းဂဏန်းတန်ဖိုးတွေ ဖြစ်နိုင်ပါတယ်။

ကိန်းသေတွေကို `:=` syntax သုံးပြီး ကြေညာလို့မရပါဘူး။

.play basics/constants.go

* ကိန်းဂဏန်းကိန်းသေများ

ကိန်းဂဏန်းကိန်းသေတွေဟာ တိကျမှုမြင့်မားတဲ့ _တန်ဖိုးတွေ_ ဖြစ်ပါတယ်။

အမျိုးအစားမသတ်မှတ်ထားတဲ့ ကိန်းသေတစ်ခုဟာ သူ့ရဲ့အခြေအနေလိုအပ်တဲ့ အမျိုးအစားကို ယူပါတယ်။

`needInt(Big)` ကိုလည်း ပုံနှိပ်ထုတ်ကြည့်ပါ။

(`int` တစ်ခုဟာ အများဆုံး 64-ဘစ် ကိန်းပြည့်တစ်ခုကို သိမ်းဆည်းနိုင်ပြီး၊ တစ်ခါတစ်ရံ အဲဒီထက်နည်းပါတယ်။)

.play basics/numeric-constants.go

* ဂုဏ်ယူပါတယ်

ဒီသင်ခန်းစာကို သင်ပြီးဆုံးသွားပါပြီ

သင်ဘာဆက်လေ့လာရမလဲဆိုတာ ရှာဖွေဖို့ [[/list][မော်ဂျူးစာရင်း]]ကို ပြန်သွားနိုင်ပါတယ်၊ ဒါမှမဟုတ် [[javascript:click('.next-page')][နောက်သင်ခန်းစာ]]နဲ့ ဆက်လက်လေ့လာနိုင်ပါတယ်။
